#' Estimate fractional cover using image regression
#' 
#' fCover takes a classified high resolution image, e.g. vegetation and non-vegetation based on Landsat and calculates cover fractions for
#' pixels of a coarser resolution, e.g. MODIS.
#' 
#' @param classImage high resolution RasterLayer containing a landcover classification, e.g. as obtained by \link{superClass}.
#' @param predImage coearse resolution RasterLayer for which fractional cover will be estimated.
#' @param nSample Integer. Number of pixels to sample from predImage to train the regression model
#' @param classes Integer. Classes for which fractional cover should be estimated. 
#' @param model Character. Which model to fit for image regression. See \link[caret]{train} for options. Defaults to randomForest ('rf')
#' @param maxNA Numeric. Maximal proportion of NAs allowed in training pixels.
#' @param tuneLength Integer. Number of levels for each tuning parameters that should be generated by train. 
#' @param tuneGrid Optional data.frame with exact tuning values. The columns are named the same as the tuning parameters. 
#' @param method Character. Resampling method for parameter tuning. Defaults to 10 fold cross-validation. See \link[caret]{trainControl} for options.
#' @param verbose Logical. Print progress information.
#' @param filename Character. Raster filename.
#' @param ... further arguments to be passed to \link[caret]{trainControl} and \code{\link[raster]{writeRaster}}
#' @details 
#' fCover gets the pixel values in a high resolution classified image that correspond to 
#' individual randomly selected moderate resolution pixels and then calculates the percent of 
#' the classified image pixels that represent your cover type of interest. In other words, if 
#' your high resolution image has a pixel size of 1m and your moderate resolution image has a 
#' pixel size of 30m the sampling process would take a block of 900 of the 1m resolution pixels 
#' that correspond to a single 30m pixel and calculate the percentage of the 1m pixels that 
#' are forest. For example, if there were 600 forest pixels and 300 non-forest pixels the value 
#' given for the output pixel would be 0.67 since 67% of the block of 1m pixels were forest. 
#' 
#' fCover relies on train from the caret package which provides acces to a huge number of classifiers.
#' Please see the available options at \link[caret]{train}. The default classifier (randomForest) we chose has been shown
#' to provide very good results in image regression and hence its recomended you start with this one. If you choose a different
#' one, make sure it can run in regression mode.
#' 
#' If you register a parallel backend before, model fitting will run in parallel.
#' 
#' If the total no-data values for a block of high resolution pixels is greater than maxNA then 
#' it will not be included in the training data set since there is too much missing data to provide 
#' a reliable cover percentage. If the no-data proporton is less then maxNA the no-data pixels are removed 
#' from the total number of pixels when calculating the percent cover. 
#' 
#' 
#' @return 
#' Returns a list with two elements: models contains the fitted models evaluated in tenfold cross-validation (caret train objects); 
#' fCover contains a RasterStack with a fractional cover layer for each requested \code{class}
#' @export 
#' @seealso \link{superClass}
#' 
fCover <- function(classImage, predImage, nSample = 5000, classes = 1, model = "rf", tuneLength = 3, 
        tuneGrid = NULL, method = "cv",  maxNA = 0.1, filename = NULL, verbose = FALSE, ...){
      
    ## Resolution check
    r1 		<- res(predImage)[1]
    r2 		<- res(classImage)[1]
    if(r2 >= r1) stop("Resolution of classImage must be smaller than the resolution of predImage")
    resFact <- r1/r2
    
    ## Subset ellipsis to separate caret::trainControl
    ## This is not needed for raster::writeRaster, which has ellipsis itself and swallows everything
    frmls_train <- names(formals(caret::trainControl))
    args  <- c(list(...), method = method)
    args_trainControl  <- args[names(args) %in% frmls_train]
    args_writeRaster   <- args[!names(args) %in% frmls_train]
    args_writeRaster$filename <- if(length(classes) == 1) filename else NULL ## write raster here already during predict if only one layer is output
    
     
    ## Draw random sample from coarse res image
    if(verbose) message("Collecting random samples")
    ranSam   <- sampleRandom(predImage, size = nSample, ext = extent(classImage), xy = TRUE, na.rm = TRUE)
    
    ## Extract classified (high res) values
    if(verbose) message("Extracting classified pixels")
    d 	 <- ranSam[,c("x","y")]
    exts <- apply(cbind(d - r1/2, d + r1/2)[,c(1,3,2,4)], 1, extent)
    vals <- lapply(exts, function(x) extract(classImage,x, na.rm=F))
   
    ## Calculate fractional cover
    if(verbose) message("Calculating fractional cover")
    tabl <- lapply(vals, function(x) table(x, useNA = "always") / length(x))
    fCov <- do.call("rbind", lapply(tabl, "[", as.character(classes)))
    fCov[is.na(fCov)] <- 0
    colnames(fCov) <- classes
    fCovNA <- lapply(tabl, tail, 1)
    include <- unlist(fCovNA < maxNA)        
    
    ## Fit regression model and predict
    fCL <- lapply(1:length(classes), function(cl){
                if(verbose) message("Fitting regression model for class ", cl)
                
                ## Assemble training data (and remove cells exceeding maxNA)
                trainingData <- data.frame(response = fCov[include, cl], ranSam[include, -c(1:2)])
                  
                ## Fit model
                modelFit 	 <- train(response ~ ., data = trainingData, method = model,
                        tuneLength = tuneLength,  
                        trControl = do.call("trainControl", args_trainControl))
                
                ## Predict  
                if(verbose) message(paste0("Predicting fractional cover for class ", cl))               
                out <- .paraRasterFun(predImage, rasterFun = raster::predict, model = modelFit, na.rm = TRUE, args=args_writeRaster)              
                list(modelFit, out)                
            })
    
    ## Prepare output and return
    out 	<- stack(lapply(fCL, "[[", 2))
    models  <- lapply(fCL, "[[", 1)
    atts 	<- attr(classImage@data, "attributes")
    names(models) <- names(out) <- paste0("fC_", if(length(atts) > 0) atts[[1]][classes,"value"] else paste0("class",classes))
    
    if(!is.null(filename) & length(classes) > 1) out <- writeRaster(out, filename, ...)
    structure(list(model = models, map = out), class = "fCover")
    
}
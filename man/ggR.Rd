% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/ggR.R
\name{ggR}
\alias{ggR}
\title{Plot RasterLayers in ggplot with greyscale}
\usage{
ggR(img, layer = 1, maxpixels = 5e+05, stretch, quantiles = c(0.02, 0.98),
  coordEqual = TRUE, alpha = 1, ggLayer = FALSE, ggObj = TRUE,
  annotation = TRUE)
}
\arguments{
\item{img}{raster}

\item{layer}{layername}

\item{maxpixels}{Integer. Maximal number of pixels to sample}

\item{stretch}{Character. Either 'lin' or 'hist' for linear or histogram stretch of the data}

\item{quantiles}{Numeric vector with two elements. Min and max quantiles to stretch to. Defaults to 2\% stretch, i.e. c(0.02,0.98).}

\item{coordEqual}{Logical. Force addition of coord_equal, i.e. aspect ratio of 1:1. Typically usefull for remote sensing data (depending on your projection), hence it defaults to TRUE.
Note however, that this does not apply if (\code{ggLayer=FALSE}).}

\item{alpha}{Numeric. Transparency (0-1).}

\item{ggLayer}{Logical. Return only a ggplot layer which must be added to an existing ggplot. If \code{FALSE} s stand-alone ggplot will be returned.}

\item{ggObj}{Logical. Return a stand-alone ggplot object (TRUE) or just the data.frame with values and colors}

\item{annotation}{Logical. Uses annotation_raster by default (good to keep aestetic mappings free). If \code{FALSE} uses geom_raster (and aes(fill)).}
}
\description{
aimed towards plotting single layer imagery in grey-scale (remote sensing data) but can be
used with any Raster* object.
}
\note{
When img contains factor values and annotation raster is \code{TRUE}, the values will be automatically converted
to numeric in order to proceed with the color calculation.
}
\examples{
library(ggplot2)
data(rlogo)

## Simple grey scale annotation
ggR(rlogo)

## With linear stretch contrast enhancement
ggR(rlogo, stretch = "lin", quantiles = c(0.1,0.9))

## Don't plot, just return a data.frame
df <- ggR(rlogo, ggObj = FALSE)
head(df)

## ggplot with geom_raster instead of annotation_raster
## and default scale_fill*
ggR(rlogo, annotation = FALSE)

## with different scale
ggR(rlogo, annotation=FALSE) + scale_fill_gradientn(name = "mojo", colours = rainbow(10)) +
        ggtitle("**Funkadelic**")

## Layermode (ggLayer=TRUE)
data <- data.frame(x = c(0, 0:100,100), y = c(0,sin(seq(0,2*pi,pi/50))*10+20, 0))
ggplot(data, aes(x, y)) +  ggR(rlogo, annotation= TRUE, ggLayer = TRUE) +
       geom_polygon(aes(x, y), fill = "blue", alpha = 0.4) +
       coord_equal(ylim=c(0,75))

## Categorical data
## In this case you probably want to use annotation=FALSE
## in order to perform aestetic mapping (i.e. a meaningful legend)
rc <- raster(rlogo)
rc[] <- cut(rlogo[[1]][], seq(0,300, 50))
ggR(rc, annotation = FALSE)

## Legend cusomization etc. ...
ggR(rc, annotation = FALSE) + scale_fill_discrete(labels=paste("Class", 1:6))
}
\seealso{
\link{ggRGB}, \link[=fortify.raster]{fortify}
}


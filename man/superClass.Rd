% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/superClass.R
\name{superClass}
\alias{superClass}
\title{Supervised Classification}
\usage{
superClass(img, trainData, valData = NULL, responseCol = NULL,
  nSamples = 1000, areaWeightedSampling = TRUE, polygonBasedCV = FALSE,
  trainPartition = NULL, model = "rf", tuneLength = 3, kfold = 5,
  minDist = 2, forceBuffer = FALSE, mode = c("regression",
  "classification"), filename = NULL, verbose, predict = TRUE,
  overwrite = TRUE, ...)
}
\arguments{
\item{img}{Raster* object. Typically remote sensing imagery, which is to be classified.}

\item{trainData}{SpatialPolygonsDataFrame or SpatialPointsDataFrame containing the training locations.}

\item{valData}{SpatialPolygonsDataFrame or SpatialPointsDataFrame containing the validation locations (optional).}

\item{responseCol}{Character or integer giving the column in \code{trainData}, which contains the response variable. Can be omitted, when \code{trainData} has only one column.}

\item{nSamples}{Integer. Number of samples per land cover class.}

\item{areaWeightedSampling}{logical. If \code{TRUE} scales sample size per polygon area. The bigger the polygon the more samples are taken.}

\item{polygonBasedCV}{Logical. If \code{TRUE} model tuning during cross-validation is conducted on a per-polygon base. Use this to combat overfitting.}

\item{trainPartition}{numeric. Partition (polygon based) of \code{trainData} that goes into the training data set between zero and one . Ignored if \code{valData} is provided.}

\item{model}{Character. Which model to use. See \link[caret]{train} for options. Defaults to randomForest ('rf')}

\item{tuneLength}{Integer. Number of levels for each tuning paramete (see \link[caret]{train} for details).}

\item{kfold}{Integer. Number of cross-validation resamples during model tuning.}

\item{minDist}{Numeric. Minumum distance factor between training and validation data, e.g. minDist=1 will clip validation polygons to ensure a minimal distance of one pixel to the next training polygon. Applies onl if trainData and valData overlap or forceBuffer is \code{TRUE}.}

\item{forceBuffer}{Logical. Forces a buffer distance of width \code{minDist} betwenn training and validation data.}

\item{mode}{Character. Model type: 'regression' or 'classification'. Will be detected automatically based on the response type. However for classification based on integer classes you will have to specify this explicitly: model='classification'.}

\item{filename}{path to output file (optional). If \code{NULL}, standard raster handling will apply, i.e. storage either in memory or in the raster temp directory.}

\item{verbose}{logical. prints progress and statistics during execution}

\item{predict}{logical. \code{TRUE} (default) will return a classified map, \code{FALSE} will only train the classifier}

\item{overwrite}{logical. Overwrite spatial prediction raster if it already exists.}

\item{...}{further arguments to be passed to \code{\link[caret]{train}}}
}
\value{
A list containing [[1]] the model, [[2]] the predicted raster and [[3]] the class mapping
}
\description{
Supervised classification both for classification and regression mode based on vector training data (points or polygons).
}
\note{
Validation on a separate (not used for training) set of polygons/points is highly advised. Automatic validation is performed either by specifying
\code{valData} or by specifying \code{trainPartition}, the amount of \code{trainData} which is to be held out for validation.
}
\examples{
library(caret)
library(randomForest)
library(e1071)
library(raster)
input <- brick(system.file("external/rlogo.grd", package="raster"))
train <- readRDS(system.file("external/training.rds", package="RStoolbox"))

## Plot training data
olpar <- par(no.readonly = TRUE) # back-up par
par(mfrow=c(1,2))
colors <- c("yellow", "green", "deeppink")
plotRGB(input)
plot(train, add = TRUE, col =  colors[train$class], pch = 19)

## Fit classifier (splitting training into 70\\\% training data, 30\\\% validation data)
SC 	  <- superClass(input, trainData = train, responseCol = "class",
model = "rf", tuneLength = 1, trainPartition = 0.7)
SC

## Plots
plot(SC$map, col = colors, legend = FALSE, axes = FALSE, box = FALSE)
legend(1,1, legend = levels(train$class), fill = colors , title = "Classes",
horiz = TRUE,  bty = "n")
par(olpar) # reset par
}
\seealso{
\code{\link[caret]{train}}
}


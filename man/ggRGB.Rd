% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/ggRGB.R
\name{ggRGB}
\alias{ggRGB}
\title{Create ggplot raster with RGB from 3 rasterLayers}
\usage{
ggRGB(img, r = 3, g = 2, b = 1, scale, maxpixels = 5e+05,
  stretch = NULL, ext = NULL, minMax = NULL, clipToMinMax = FALSE,
  quantiles = c(0.02, 0.98), ggObj = TRUE, ggLayer = FALSE, alpha = 1,
  coordEqual = TRUE, annotation = TRUE)
}
\arguments{
\item{img}{RasterStack or RasterBrick}

\item{r}{Integer or character. Red layer in x. Can be set to \code{NULL}, in which case the red channel will be set to zero.}

\item{g}{Integer or character. Green layer in x. Can be set to \code{NULL}, in which case the green channel will be set to zero.}

\item{b}{Integer or character. Blue layer in x. Can be set to \code{NULL}, in which case the blue channel will be set to zero.}

\item{scale}{Numeric. Maximum possible pixel value (optional). Defaults to 255 or to the maximum value of x if that is larger than 255}

\item{maxpixels}{Integer. Maximal number of pixels used for plotting.}

\item{stretch}{Character. Either 'lin' or 'hist' for linear or histogram stretch of the data}

\item{ext}{extent object tp crop the image}

\item{minMax}{Vector or matrix. Can be used to reduce the range of values. Either a vector of two values for all bands (c(min, max))
or a 3x2 matrix with separate min and max values (columns) for each layer (rows).}

\item{clipToMinMax}{Logical. If \code{TRUE}, values > scale will be set to NA. if \code{FALSE} they will be set to scale. Defaults to \code{FALSE}.}

\item{quantiles}{Numeric vector with two elements. Min and max quantiles to stretch to. Defaults to 2\% stretch, i.e. c(0.02,0.98).}

\item{ggObj}{Logical. If \code{TRUE} a ggplot2 object is returned. If \code{FALSE} a data.frame with coordinates and color will be returned.}

\item{ggLayer}{Logical. If \code{TRUE} a ggplot2 layer is returned. This is usefull if you want to add it to an existing ggplot2 object.
Note that if \code{TRUE} & \code{annotate = FALSE} you have to add a scale_fill_identity() manually in your call to ggplot().}

\item{alpha}{Numeric. Transparency (0-1).}

\item{coordEqual}{Logical. Force addition of coord_equal, i.e. aspect ratio of 1:1. Typically usefull for remote sensing data (depending on your projection), hence it defaults to TRUE.
Note howver, that this does not apply if (\code{ggLayer=FALSE}).}

\item{annotation}{Logical. If \code{TRUE} annotation_raster is used, otherwise geom_raster()+scale_fill_identity is used.
Note that you can't use scale_fill* in addition to the latter, because it already requires scale_fill_identity().}
}
\value{
A ggplot2 object, or a three column data frame with coordinates and fill colour.
}
\description{
Calculates RGB color composite raster for plotting with ggplot2. Optional value clipping and and stretching can be used to enhance the imagery.
}
\details{
Functionality is based on \code{\link[raster]{plotRGB}} from the raster package.
}
\examples{
br <- brick(system.file("external/rlogo.grd", package="raster"))
ggRGB(br, 1, 2, 3)
ggRGB(br, r=1,g=2,b=3, minMax = matrix(c(100,150,10,200,50,255),  ncol = 2, by = TRUE))
}
\seealso{
\link{ggR}, \link[=fortify.raster]{fortify}
}

